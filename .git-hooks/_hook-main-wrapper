#!/bin/sh

# Loop through the sub-hooks in the <hook>.d dir and call them in a
# sorted order after ignoring files with extensions.
#
# To create a new hook, simply follow the 'commit-msg' hook pattern.
#
# The 'commit-msg' hook calls the 'hook-main-wrapper' script which
# calls the sub-hooks in the 'commit-msg.d' dir after ignoring files
# with extensions and sorting in the default sort order of 'ls'
# command.
#
# Steps:
#
#  - Create the main hook script ('commit-msg') and copy the content.
#  - Create a <hook>.d dir ('commit-msg.d').
#  - Put sub-hooks in dir. Number sub-hooks in order of how they are to
#    to called. To ignore a sub-hook, add any extension to it.

# clean up
cleanUp() {
	rm -f .git/hook.change
}
export -f cleanUp

# config get
getConfig() {
	git config --get "$1"
}
export -f getConfig

# Call sub-hooks in <hook>.d dir.
callSubhooks() {
	# skip hooks
	if [ "$SKIP_HOOKS" == "true" ]; then
		return
	fi
	# hookname is passed as env variable
	hookdir="$hookname.d"
	if [ -d ~/.git-hooks/"$hookdir" ]; then
		# ignore files with extensions
		subhooks=$( ls -I '*.*' -1 ~/.git-hooks/"$hookdir" )
		if [ ! -z "$subhooks" ]; then
			# echo hook name only if there are subhooks
			echo "hooks/$hookname"
			for subhook in $subhooks; do
				~/.git-hooks/"$hookdir"/"$subhook" "$@"
				# check exit code and exit if needed
				exitcode=$?
				if [ $exitcode -ne 0 ]; then
					exit $exitcode
				fi
			done
		fi
	fi
}


callSubhooks "$@"
