#!/bin/sh
# From Gerrit Code Review 2.12
#
# Part of Gerrit Code Review (https://www.gerritcodereview.com/)
#
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# rm: 
echo "hooks/commit-msg"

unset GREP_OPTIONS

CHANGE_ID_AFTER="Bug|Issue|Test"
MSG="$1"

# Check for, and add if missing, a unique Change-Id
#
add_ChangeId() {
	clean_message=`sed -e '
		/^diff --git .*/{
			s///
			q
		}
		/^Signed-off-by:/d
		/^#/d
	' "$MSG" | git stripspace`
	if test -z "$clean_message"
	then
		return
	fi

	# Do not add Change-Id to temp commits
	if echo "$clean_message" | head -1 | grep -q '^\(fixup\|squash\)!'
	then
		return
	fi

	if test "false" = "`git config --bool --get gerrit.createChangeId`"
	then
		return
	fi

	# Does Change-Id: already exist? if so, exit (no change).
	if grep -i '^Change-Id:' "$MSG" >/dev/null
	then
		return
	fi

	id=`_gen_ChangeId`
	T="$MSG.tmp.$$"
	AWK=awk
	if [ -x /usr/xpg4/bin/awk ]; then
		# Solaris AWK is just too broken
		AWK=/usr/xpg4/bin/awk
	fi

	# How this works:
	# - parse the commit message as (textLine+ blankLine*)*
	# - assume textLine+ to be a footer until proven otherwise
	# - exception: the first block is not footer (as it is the title)
	# - read textLine+ into a variable
	# - then count blankLines
	# - once the next textLine appears, print textLine+ blankLine* as these
	#   aren't footer
	# - in END, the last textLine+ block is available for footer parsing
	$AWK '
	BEGIN {
		# while we start with the assumption that textLine+
		# is a footer, the first block is not.
		isFooter = 0
		footerComment = 0
		blankLines = 0
	}

	# Skip lines starting with "#" without any spaces before it.
	/^#/ { next }

	# Skip the line starting with the diff command and everything after it,
	# up to the end of the file, assuming it is only patch data.
	# If more than one line before the diff was empty, strip all but one.
	/^diff --git / {
		blankLines = 0
		while (getline) { }
		next
	}

	# Count blank lines outside footer comments
	/^$/ && (footerComment == 0) {
		blankLines++
		next
	}

	# Catch footer comment
	/^\[[a-zA-Z0-9-]+:/ && (isFooter == 1) {
		footerComment = 1
	}

	/]$/ && (footerComment == 1) {
		footerComment = 2
	}

	# We have a non-blank line after blank lines. Handle this.
	(blankLines > 0) {
		print lines
		for (i = 0; i < blankLines; i++) {
			print ""
		}

		lines = ""
		blankLines = 0
		isFooter = 1
		footerComment = 0
	}

	# Detect that the current block is not the footer
	(footerComment == 0) && (!/^\[?[a-zA-Z0-9-]+:/ || /^[a-zA-Z0-9-]+:\/\//) {
		isFooter = 0
	}

	{
		# We need this information about the current last comment line
		if (footerComment == 2) {
			footerComment = 0
		}
		if (lines != "") {
			lines = lines "\n";
		}
		lines = lines $0
	}

	# Footer handling:
	# If the last block is considered a footer, splice in the Change-Id at the
	# right place.
	# Look for the right place to inject Change-Id by considering
	# CHANGE_ID_AFTER. Keys listed in it (case insensitive) come first,
	# then Change-Id, then everything else (eg. Signed-off-by:).
	#
	# Otherwise just print the last block, a new line and the Change-Id as a
	# block of its own.
	END {
		unprinted = 1
		if (isFooter == 0) {
			print lines "\n"
			lines = ""
		}
		changeIdAfter = "^(" tolower("'"$CHANGE_ID_AFTER"'") "):"
		numlines = split(lines, footer, "\n")
		for (line = 1; line <= numlines; line++) {
			if (unprinted && match(tolower(footer[line]), changeIdAfter) != 1) {
				unprinted = 0
				print "Change-Id: I'"$id"'"
			}
			print footer[line]
		}
		if (unprinted) {
			print "Change-Id: I'"$id"'"
		}
	}' "$MSG" > "$T" && mv "$T" "$MSG" || rm -f "$T"
}
_gen_ChangeIdInput() {
	echo "tree `git write-tree`"
	if parent=`git rev-parse "HEAD^0" 2>/dev/null`
	then
		echo "parent $parent"
	fi
	echo "author `git var GIT_AUTHOR_IDENT`"
	echo "committer `git var GIT_COMMITTER_IDENT`"
	echo
	printf '%s' "$clean_message"
}
_gen_ChangeId() {
	_gen_ChangeIdInput |
	git hash-object -t commit --stdin
}

# rm:
# Internal fn to format messages with 50/72 convention
applyCommitMessageConventionInternal() {
	msg="$1"
	msgbak="$msg".bak
	msgconvention="$msg".convention
	msgText=$(cat "$msg")
	# if msg is empty (blank lines and comments) then exit
	if [[ $(validTextCount "$msgText") -eq 0 ]]; then
		# exit and let git handle abort or continue (--allow-empty-message)
		exit
	fi
	# cp "$msg" "$msgbak"
	# clean msg to trim lines and remove starting blank lines
	echo "$msgText" | sed 's/ *$//' | sed '/./,$! d' > "$msgbak"
	# subject
	subject=$(head -n 1 "$msgbak")
	# echo $subject
	if [[ "$subject" == "Merge branch"* ]] \
		|| [[ "$subject" == "Merge remote-tracking branch"* ]]; then
		echo "  keeping merge commit subject as is"
		echo "$subject" > "$msgconvention"
	else
		# hack: warn if subject >$subjectLen chars
		# with exit, user will have to type message again
		if [ ${#subject} -gt $subjectLen ]; then
			echo "  WARNING: subject should be upto $subjectLen chars"
		fi
		echo "$subject" | fmt -s -w $subjectLen > "$msgconvention"
	fi
	# apply only if body is not empty
	rest=$(tail -n +2 "$msgbak")
	if [[ $(validTextCount "$rest") -ne 0 ]]; then
		# 2nd line should be blank
		bodylineStart=2
		line2=$(echo "$rest" | head -n 1)
		if [[ $(validTextCount "$line2") -ne 0 ]]; then
			echo "  adding a blank line after subject"
			bodylineStart=1
		fi
		echo "" >> "$msgconvention"
		# body
		body=$(echo "$rest" | tail -n +"$bodylineStart")
		# fmt does not handle '#' properly so filter out
		echo "$body" | sed '/^#/ d' | fmt -s -w $bodyLen >> "$msgconvention"
	else
		echo "" >> "$msgconvention"
	fi
	# put back '#' lines by appending
	echo "$rest" | sed -n '/^#/ p' >> "$msgconvention"
	# copy .convention to msg
	cp "$msgconvention" "$msg"
}

# text count after removing comments
validText() {
	text="$1"
	echo "$text" | sed '/^#/ d'
}
# text count after removing spaces (even between words), newlines
validTextCount() {
	text="$1"
	echo $(validText "$text") | tr -d " \r\n" | wc -c
}

# compare files exactly
fileCompare() {
	if cmp --silent "$1" "$2"; then
		# true
		return 0
	else
		# false
		return 1
	fi
}
# compare files as per git significant content
#   exclude comments
fileCompareRelaxed() {
	text1=$(cat "$1")
	text2=$(cat "$2")
	text1=$(validText "$text1")
	text2=$(validText "$text2")
	#~ echo "text1 $text1"
	#~ echo "text2 $text2"
	if [[ "$text1" == "$text2" ]]; then
		# true
		return 0
	else
		# false
		return 1
	fi
}

# Format commit messages with 50/72 convention
subjectLen=50
bodyLen=72
applyCommitMessageConvention() {
	echo "  apply $subjectLen/$bodyLen commit message convention"
	# msg is user edited
	msg="$1"
	# msg.original is copy of msg
	msgoriginal="$msg".original
	# msg.bak is copy of msg
	msgbak="$msg".bak
	# msg.convention is for convention
	msgconvention="$msg".convention
	# clear
	> "$msgbak"
	> "$msgconvention"
	# copy msg to msgoriginal
	cp "$msg" "$msgoriginal"
	editor=$(git config core.editor)
	# read user input below
	exec < /dev/tty
	while true; do
		applyCommitMessageConventionInternal "$msg"
		if fileCompareRelaxed "$msgconvention" "$msgbak"; then
			# no change after applying convention, return
			echo "  no change after applying convention"
			echo "  done"
			return;
		fi
		echo "  changing message"
		$editor "$msg"
		if fileCompare "$msg" "$msgconvention"; then
			echo "  no manual change"
			read -p "  now what? (*/u/a/f/o) " ans
			case $ans in
				[uU] )
					# undo and show
					echo "  undoing";
					cp "$msgbak" "$msg"
					$editor "$msg"
					# if no diff then return
					if fileCompare "$msg" "$msgbak"; then
						echo "  no manual change after undo"
						echo "  done"
						return;
					fi
					;;
				[aA] )
					# abort commit by exit
					echo "  aborting commit";
					exit 1;;
				[fF] )
					# force message
					echo "  forcing message";
					$editor "$msg"
					return;;
				[oO] )
					# original message
					echo "  original message";
					cp "$msgoriginal" "$msg"
					$editor "$msg"
					return;;
				* )
					# all ok, so commit
					echo "  done";
					return;;
			esac
		fi
	done
}

# Check if semver line is included
checkSemver() {
	echo "  check if semver line is included"
	msg="$1"
	if ! egrep -q "#MAJOR|#MINOR|#PATCH" $msg; then
		echo -e "  WARNING: #MAJOR #MINOR #PATCH line is NOT included"
	fi
}

# rm:
if [ -f .git/hooks/skip-cmc ]; then
	echo "  SKIPPING applyCommitMessageConvention: .git/hooks/skip-cmc file present"
else
	applyCommitMessageConvention "$1"
fi

if [ -f .git/hooks/check-semver ]; then
	checkSemver "$1"
fi

if [ -f .git/hooks/changeid ]; then
	add_ChangeId
else
	echo "  SKIPPING add_ChangeId: .git/hooks/changeid file NOT present"
fi
